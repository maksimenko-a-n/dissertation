%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Алгоритмы прямого типа
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\texorpdfstring{Кликовое число полиэдрального графа\\ и алгоритмы прямого типа}{Кликовое число полиэдрального графа и алгоритмы прямого типа}
\chapter{Алгоритмы прямого типа}
\label{chap:Direct}

%\hfill
%\begin{minipage}{0.55\textwidth}
%Плотность графа многогранника задачи служит нижней оценкой вычислительной сложности в широком классе алгоритмов, основанных на линейных сравнениях.
%~\hfill
%\begin{flushright}
%\emph{В.\,А.~Бондаренко}
%\end{flushright}
%\end{minipage}

\section{Теория алгоритмов прямого типа}

В монографии \cite{BondBook:1995} кликовое число (называемое в этой работе плотностью) графа многогранника 
рассматривается как нижняя оценка сложности соответствующей задачи
в <<некотором широком>> классе так называемых алгоритмов прямого типа. 
Алгоритмы прямого типа относятся к классу линейных разделяющих алгоритмов,
которые удобно представлять в виде линейных разделяющих деревьев.

В этой главе, следуя \cite{BondBook:1995}, задачей будет называться множество допустимых решений $X = X(I) \in \R^m$, из которого требуется выбрать решение $\bm{x}$, оптимальное относительно подаваемого на вход задачи целевого вектора $\bm{c} \in \R^m$.
Обратим внимание читателя на то, что, в отличие от используемых в предыдущих главах определений~\ref{def:LCOP} и~\ref{def:family}, задачей в рамках обсуждаемой теории называется не семейство множеств допустимых решений задачи, а лишь одно из этих множеств.

Так же, как это было сделано в разделе~\ref{sec:Cones}, для каждого $\bm{x} \in X$ определим конус исходных данных
\begin{equation}
\label{eq:cone}
K(\bm{x}) = \Set*{\bm{c}\in \R^m \given  \bm{c}^T \bm{x} \ge \bm{c}^T \bm{y}, \ \forall \bm{y} \in X}.
\end{equation}
В случае, если множество исходных данных задачи ограничено полиэдром $Q \subseteq \R^m$, используем обозначение $K(\bm{x}, Q) = K(\bm{x}) \cap Q$.

\begin{definition}[{{\cite[с. 33]{BondBook:1995}}}] %{\cite[с. 33]{BondBook:1995}}
	Линейным  разделяющим деревом задачи $X \subset \R^m$ называется ориентированное дерево, обладающее следующими свойствами:
	\begin{itemize}
		\item[а)] 
		в каждый узел, за исключением одного, называемого  корнем,
		входит ровно одна дуга; дуг, входящих в корень, нет;
		\item[б)] 
		для каждого узла либо имеется две выходящих из него  дуги,
		либо таких дуг  нет  вообще;   в  первом  случае  узел  называется
		внутренним, во втором "--- внешним, или листом;
		\item[в)] 
		каждому внутреннему узлу соответствует некоторый вектор $\bm{f} \in \R^m$;
		\item[г)] 
		каждому листу соответствует некоторый элемент множества $X$, причем нескольким листьям может соответствовать один и тот же элемент из $X$;
		\item[д)] 
		каждой дуге $d$ соответствует число  $\sgn d$, равное $1$ либо $-1$;
		две дуги, выходящие из одного узла, имеют различные значения;
		\item[е)] 
		для каждой цепи $W = \bm{f_1} d_1 \bm{f_2} d_2 \ldots \bm{f_l} d_l \bm{x}$, соединяющей корень и лист (в обозначении  цепи  перечислены  соответствующие  ее  узлам векторы; дуга $d_i$ выходит из узла $\bm{f_i}$, $i\in[l]$), и для любого $\bm{c}\in \R^m$ из неравенств $\bm{c}^T \bm{f_i} \sgn d_i\ge 0$, $i\in[l]$, следует включение $\bm{c}\in K(\bm{x})$.
	\end{itemize}
\end{definition}

\emph{Сложностью $C_{LSA}(X)$ задачи $X$ в классе линейных разделяющих алгоритмов}
называется высота (глубина) минимального линейного разделяющего дерева этой задачи.
Очевидно, $C_{LSA}(X) \ge \log_2 |X|$ (разумеется, при условии, 
что $X$ не содержит решений, не являющихся оптимальными ни при каком входе $\bm{c}$).
В~1982~г. М.\,Ю.~Мошков показал~\cite{Moshkov:1982}, что $C_{LSA}(X) = O (m^3 \log_2 |X|)$ для любой задачи $X\in\R^m$. То есть NP-трудные задачи в рамках этой парадигмы приравниваются к полиномиально разрешимым.
Такое положение дел заставляет предположить, 
что существующие алгоритмы удовлетворяют некоторым дополнительным ограничениям,
существенно снижающим их эффективность.
Одно из таких ограничений было предложено В.\,А.~Бондаренко в~1980"~х~гг.

В \cite{BondBook:1995} предложены два формально разных варианта определения
алгоритма прямого типа, в основе которых лежит одна и та же идея,
основанная на понятии графа решений задачи.

Как и прежде, мы ограничиваемся рассмотрением тех случаев, когда множество исходных данных (допустимых целевых векторов) задачи $X \subset \R^m$ совпадает с $\R^m$ или же представляет собой полиэдр $Q \subseteq \R^m$.

\begin{definition}[\cite{MaksimenkoDiss:2004}]
\label{def:AdjSolutions}
Вершинами \emph{графа решений} задачи $X \subset \R^m$ с ограничением $Q \subseteq \R^m$ являются те решения $\bm{x} \in X$, которые удовлетворяют условию 
\begin{equation*}
	\exists \bm{c} \in Q \quad \forall \bm{z}\in X \setminus \{\bm{x}\} \quad \bm{c}^T \bm{x} > \bm{c}^T \bm{z}.
\end{equation*}
Две вершины $\bm{x}$ и $\bm{y}$ графа решений \emph{смежны}, если найдется $\bm{c} \in Q$ такой, что
\begin{equation*}
%\label{eq:adjacent}
	\exists \bm{c} \in Q \quad \forall \bm{z}\in X \setminus \{\bm{x}, \bm{y}\} \quad \bm{c}^T \bm{x} = \bm{c}^T \bm{y} > \bm{c}^T \bm{z}.
\end{equation*}
\end{definition}

Заметим, что определение смежных решений эквивалентно определению смежных конусов (на с.~\pageref{AdjCones}) и, если множество исходных данных совпадает с $\R^m$, определению смежных вершин многогранника $\conv(X)$.

Подмножество решений $Y \subseteq X$ называем \emph{кликой}, если соответствующие вершины графа решений попарно смежны.
Кликовое число графа решений обозначаем $\omega(X,Q)$, если же ограничение $Q$ отсутствует (то есть $Q = \R^m$), пользуемся коротким $\omega(X)$.

Введем, следуя \cite{BondBook:1995}, несколько вспомогательных обозначений.
Пусть $T$ "--- линейное  разделяющее  дерево  задачи $X$  и
пусть $\bm{f}$ "---  его  внутренний  узел.
Обозначим через $X_f$, $X_f \subseteq X$,  множество пометок всех листьев дерева $T$,
которым  предшествует  узел $\bm{f}$, а через $X_f^+$ и $X_f^-$  обозначим
подмножества $X_f$, соответствующие  двум выходящим из $\bm{f}$ дугам.
Обозначим через $R_f^- = X_f^+ \setminus X_f^-$ множество пометок,
отбрасываемых при переходе по <<отрицательной>> дуге.
По аналогии определим множество пометок $R_f^+ = X_f^- \setminus X_f^+$,
отбрасываемых при переходе по <<положительной>> дуге.

\begin{definition}[{{\cite[с.~39]{BondBook:1995}}}] %[{\cite[с. 39]{BondBook:1995}}]
	\label{def:direct-type}
	Линейное разделяющее  дерево $T$ задачи $X$
	называется деревом прямого типа, если для любого внутреннего узла $\bm{f}$ и
	для любой клики $Y \subseteq X$ выполняется неравенство
	\begin{equation}
	\min \{ |R_f^+ \cap Y|, |R_f^- \cap Y| \} \le 1.
	\label{eq:direct-type}
	\end{equation}
\end{definition}


\begin{definition}[{{\cite[с. 40]{BondBook:1995}}}] %[{\cite[с. 40]{BondBook:1995}}]
	\label{def:direct-type2}
	Деревом <<прямого  типа>> задачи $X$, $X\in R^m$,
	называется линейное разделяющее  дерево  этой  задачи,  для  которого
	каждая цепь $w = \bm{f_1} d_1 \bm{f_2} d_2 \ldots \bm{f_l} d_l \bm{x}$,  соединяющая  корень  и  лист,
	удовлетворяет условиям:
	\begin{itemize}
		\item[(*)] 
		для любого $\bm{y}\in X$ смежного  с $\bm{x}$,  найдется  такой  номер $i\in [l]$, что условия $\bm{c}^T \bm{f_i} \sgn d_i > 0$ и $\bm{c}\in K(\bm{y})$ несовместны;
		\item[(**)] 
		для любого $i\in[l]$ из несовместности условий
		\[
		\bm{c}^T \bm{f_i} \sgn d_i > 0 \qquad \mbox{и} \qquad \bm{c}\in K(\bm{y})
		\]
		для $\bm{y}$, смежного с $\bm{x}$, и из телесности конуса
		\[
		K(\bm{x}) \cap \Set*{ \bm{c}\in R^m \given \bm{c}^T \bm{f_i} \sgn d_i \le 0}
		\]
		следует, что ветвь, начинающаяся в узле $\bm{f_i}$ с  дугой  $-d_i$,  имеет хотя бы один лист, помеченный $\bm{x}$.
	\end{itemize}
\end{definition}

Оба этих определения объединяет следующий факт.

\begin{theorem}[{\cite{BondBook:1995}}] %[{\cite[раздел 2.4]{BondBook:1995}}]
\label{the:direct-type}
Высота дерева прямого типа (<<прямого типа>>) задачи $X$ не меньше $\omega(X)-1$.
\end{theorem}

Таким образом, мощность максимальной клики является нижней оценкой трудоемкости
для такого типа алгоритмов.

Известно~(см. обзор в разделе~\ref{sec:CliqueNumber}), что для классических полиномиально разрешимых задач (сортировка, минимальное остовное дерево, минимальный разрез) эта характеристика не превосходит размерности многогранника.
Ниже, в разделе~\ref{sec:ShortPathClique}, будет доказано, что задача о кратчайшем пути (с ограничением неотрицательности длин контуров) тоже входит в этот список.

С другой стороны, в главах \ref{chap:AffTheory} и \ref{chap:AffExamples} показано, что булевы квадратичные многогранники $\BQP$ аффинно сводятся к многогранникам таких труднорешаемых задач, как коммивояжер, рюкзак, 3-выполнимость, 3-сочетание, покрытие и упаковка множества, раскраска графа, кубический подграф и многие другие. Учитывая, что кликовое число графа многогранника $\BQP(n)$ равно $2^n$, кликовые числа графов многогранников указанных задач также сверхполиномиальны по размерности многогранников.
Кроме того, в~\cite{BondBook:1995} установлено, что некоторые алгоритмы сортировки, жадный алгоритм для минимального остовного дерева,
алгоритм Дейкстры для кратчайшего пути, алгоритм Хелда--Карпа 
и реализация алгоритма ветвей и границ для задачи коммивояжера
являются прямыми или <<прямыми>>.
(Хотя, в контексте приводимых ниже замечаний, 
некоторые из этих результатов могут быть подвергнуты сомнению.)

Ниже, в~разделе~\ref{sec:ShortPathClique}, будет показано, что кликовое число для задачи о кратчайшем пути в орграфе на $n$ вершинах с ограничением неотрицательности длин контуров (а также для задачи с классическим ограничением неотрицательности длин дуг) равно $\lfloor n^2 / 4\rfloor$.
С учетом следствия~\ref{cor:Short2Assign}, это дает нижнюю оценку $\lfloor (n+1)^2 / 4\rfloor$ для кликового числа графа многогранника задачи о назначениях $\Birk(n)$.
В этой связи отметим следующие факты.
В~1977~г. Бруальди и Гибсон показали (см.~\cite[Theorem~6.1, Corollary~6.5]{Brualdi:1977II} и~\cite[Corollary~3.7]{Brualdi:1977I}), что любая 2-смежностная грань многогранника $\Birk(n)$, число вершин которой не равно шести, является симплексом, а максимальное число вершин такой грани совпадает с упомянутой выше оценкой $\lfloor (n+1)^2 / 4\rfloor$.
В~\cite{BondBook:1995} приводится кубическая верхняя оценка для $\omega(\Birk(n))$, но доказательство опирается на неверное рассуждение (см. следствие~\ref{cor:Edmonds} ниже).
Вычислительный эксперимент дает следующие оценки:
$\omega(\Birk(4)) = 6$, $\omega(\Birk(5)) = 13$, $\omega(\Birk(6)) = 18$, $\omega(\Birk(7)) = 23$, $\omega(\Birk(8)) = 29$, $\omega(\Birk(9)) \ge 39$.

В разделе~\ref{sec:NondirectAlg} перечисляется ряд фактов, демонстрирующих ограниченность применимости этого подхода к оценке сложности задач.
Приводится доказательство того, что алгоритм Куна--Манкреса для задачи о назначениях не является алгоритмом прямого типа.
Кроме того, описывается достаточно универсальный способ модификации алгоритмов,
существенно не меняющий их трудоемкости, но гарантированно выводящий их из класса алгоритмов прямого типа.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Задача о кратчайшем пути
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Кликовое число для задачи о кратчайшем орпути}
\label{sec:ShortPathClique}

Пусть $D = (V,A)$ "--- полный орграф, в котором выделены две вершины $s,t\in V=\{v_1,v_2,\ldots,v_n\}$. Для определенности будем считать, что $s=v_1$ и $t=v_n$. Каждой дуге $a_{ij}\in A$ ($i\ne j$, $i\in[n-1]$, $j\in\{2,3,\ldots,n\}$) в этом графе приписана длина $c_{ij}$. 
Задача о кратчайшем орпути состоит в отыскании в орграфе $D$ пути, берущего начало в вершине $s$ и заканчивающегося в $t$, суммарный вес дуг которого был бы минимальным.

В разделе~\ref{sec:ShortPath2Assignment} уже было сказано о том, что гранью многогранника $s$-$t$ орпутей $\Dipath(n)$ являтся многогранник гамильтоновых контуров $\ATSP(n-1)$. Откуда следует, в частности, что эта задача в общем случае NP-трудна, а кликовое число графа многогранника $\Dipath(n)$ сверхполиномиально.
Если~же в~орграфе~$D$ отсутствуют контуры отрицательной длины, то соответствующий полиэдр $\ShortP(n)$ имеет компактное описание, а задача становится полиномиально разрешимой. 

Ниже будет показано, что кликовое число графа конусного разбиения задачи о кратчайшем орпути с ограничением неотрицательности контуров и, вместе с ним, кликовые числа графов полиэдров $\ShortP(n)$, $\Dipath^{\uparrow}(n)$ и $\Path^{\uparrow}(n)$, равны $\lfloor n^2/4\rfloor$.
Для этого нам понадобится критерий смежности решений, сформулированный ранее в лемме~\ref{lem:path}. 

%\begin{lemma}[\cite{MaksimenkoDiss:2004}]
%\label{thm:ShortPathAdj}
%Допустимые решения $\bm{x}$ и $\bm{y}$ задачи $\Dipath(n)$ с ограничением неположительности длин контуров $S$ смежны тогда и только тогда, когда для соответствующих путей $\tx$ и $\ty$ симметрическая разность $\tx \symdiff \ty$ образует двойной путь.
%\end{lemma}
%\renewcommand{\proofname}{Доказательство леммы~\ref{lem:path}}
\begin{proof}[леммы~\ref{lem:path}]
С целью унификации рассуждений, будем рассматривать задачу на максимум, то есть задачу о длиннейшем орпути с ограничением неположительности длин контуров.
Множество целевых векторов (то есть векторов длин дуг), удовлетворяющих этому ограничению, далее обозначаем $S$.

Для каждого решения $\bm{x} \in \Dipath(n)$ соответствующий ему орпуть (точнее, множество его дуг) в орграфе $D$ будем обозначать $\tx$.

Будем говорить, что симметрическая разность $\tx \symdiff \ty$ является \emph{двойным путем}, если она представляет собой неориентированный цикл, состоящий из двух орпутей, имеющих общее начало и общий конец, и не имеющих других общих вершин.
%Пару орпутей, имеющих общее начало, заканчивающихся в другой общей вершине и не имеющих общих промежуточных вершин, будем называть \emph{двойным путем}.

Покажем что, если $\tx \symdiff \ty$ не является двойным путем, то соответствующие решения $\bm{x}$ и $\bm{y}$ несмежны.
Согласно определению~\ref{def:AdjSolutions} смежных решений, для этого
достаточно убедиться в том, что для каждого вектора длин дуг $\bm{c} \in S$, 
удовлетворяющего равенству $\bm{c}^T \bm{x} = \bm{c}^T \bm{y}$, найдется такой 
вектор $\bm{z_c}\in \Dipath(n)$, отличный от $\bm{x}$ и от $\bm{y}$, 
что выполнено $\bm{c}^T \bm{z_c} \ge \bm{c}^T \bm{x}$.

Двигаясь по путям $\tx$ и $\ty$ от начальной вершины $s$, дойдем до первой вершины $b$, входящей в $\tx \symdiff \ty$ (точнее, инцидентной одной из дуг этого множества). Очевидно, что участки этих путей от $s$ до $b$ совпадают. 
Теперь от вершины $b$ будем двигаться по пути $\tx$ до пересечения с путем $\ty$; обозначим эту вершину $p$.
Такую же операцию проделаем на пути $\ty$. Будем двигаться по нему, начиная с $b$, пока не пересечемся с $\tx$; вершину пересечения обозначим $q$. 
Если $\tx \symdiff \ty$ "--- не двойной путь, тогда, очевидно, часть пути 
$\tx$ от $p$ до конечной вершины $t$ не совпадает с частью пути 
$\ty$ от $q$ до $t$ (в частности, такая ситуация возникает,
когда $p\ne q$).

Построим два новых пути $\tilde{x_1}$ и $\tilde{y_1}$ следующим
образом. 
Новый путь $\tx_1$ будет состоять из части пути $\ty$ от вершины $s$ до $q$
и части пути $\tx$ от $q$ до $t$.
Путь $\ty_1$ будет состоять из части пути $\tx$ от вершины $s$ до $p$
и части пути $\ty$ от $p$ до $t$. Очевидно, что это будут простые пути без самопересечений, отличные от $\tx$ и $\ty$. Далее рассмотрим два случая.

Начнем с простого. Предположим, что вершины $p$ и $q$ 
совпадают. Тогда набор дуг, из которых состоят пути $\tx$ и $\ty$,
совпадает с набором дуг, образующих пути $\tx_1$ и $\ty_1$.
Следовательно,
\[
\bm{c}^T \bm{x} + \bm{c}^T \bm{y} = \bm{c}^T \bm{x_1} + \bm{c}^T \bm{y_1},
\]
где $\bm{x_1}$ и $\bm{y_1}$ "--- характеристические вектора путей $\tx_1$ и $\ty_1$.
Очевидно, что в таком случае для каждого $\bm{c}\in S$, удовлетворяющего
равенству $\bm{c}^T \bm{x} = \bm{c}^T \bm{y}$, всегда можно будет подобрать такой 
$\bm{z_c} \in \{\bm{x_1}, \bm{y_1}\}$, для которого $\bm{c}^T \bm{z_c} \ge \bm{c}^T \bm{x} + \bm{c}^T \bm{y}$. 
И решения $\bm{x}$ и $\bm{y}$ несмежны.

Теперь рассмотрим случай, когда вершины $p$ и $q$ несовпадают. Тогда часть пути $\tx$ от вершины $p$ до вершины $q$ и часть пути $\ty$ от $q$ до $p$ 
образуют некоторое множество дуг $\tilde g$, не вошедших в пути $\tx_1$ и $\ty_1$. То есть для любого $\bm{c} \in \R^m$ выполнено
\begin{equation*}
%\label{ShoEq}
\bm{c}^T \bm{x} + \bm{c}^T \bm{y} = \bm{c}^T \bm{g} + \bm{c}^T \bm{x_1} + \bm{c}^T \bm{y_1},
\end{equation*}
где $\bm{g}$ "--- характеристический вектор множества $\tilde g$.
Очевидно, что $\tilde g$ представляет собой сложный контур 
(возможно имеющий самопересечения), для каждой вершины которого число входящих дуг равно числу исходящих.

Покажем, что сложный контур всегда можно представить как объединение
простых контуров. Будем двигаться по пути $\tx$ из вершины $p$ до тех пор,
пока не попадем в вершину $r$, инцидентную одной из дуг множества $\tilde g \cap \ty$ (такой вершиной может оказаться вершина $q$).
Построим новый контур $\tilde g_1$ из участка пути $\tx$ 
от вершины $p$ до $r$ и из участка пути $\ty$ от $r$ до $p$; 
очевидно, что это будет простой контур. 
Удалив из $\tilde g$ все дуги, вошедшие в $\tilde g_1$, 
получим новый контур $\tilde g'$, состоящий из части простого пути 
$\tx$, ведущей из вершины $r$ в $q$, и части простого пути $\ty$,
ведущей из $q$ в $r$. Если контур $\tilde g'$ оказался сложным, 
то будем повторять процедуру выделения простого контура, пока все дуги не будут исчерпаны. 

Итак, сложный контур $\tilde g$ всегда можно представить как объединение простых контуров $\tilde g_k$, $k \in[l]$:
\[
\tilde g=\bigcup_{k=1}^l \tilde g_k.
\]
Учитывая, что в орграфе $D$ отсутствуют контуры положительной длины, получаем
\[
\bm{c}^T \bm{g} \le 0.
\]
Следовательно,
\[
\bm{c}^T \bm{x} + \bm{c}^T \bm{y} \le \bm{c}^T \bm{x_1} + \bm{c}^T \bm{y_1}.
\]
Таким образом, как и в случае $p = q$, решения $\bm{x}$ и $\bm{y}$ являются несмежными.

Для доказательства обратного утверждения предположим, что решения $\bm{x}$ и $\bm{y}$ несмежны. Покажем, что в таком случае множество 
$\tx \symdiff \ty$ "--- не является двойным путем.
Определим координаты вектора $\bm{c'} \in \R^m$ формулой
\[
c'_i=\left\{
\begin{array}{ll}
0,      &\mbox{если} \quad x_i=1, \quad \mbox{или} \quad y_i=1\\
-1,      &\mbox{если} \quad x_i=y_i=0.\\
\end{array}
\right.
\]
Очевидно, что $\bm{c'}\in S$ и $\bm{c'}^T \bm{x} = \bm{c'}^T \bm{y} = 0$.
А из условия несмежности следует, что существует $\bm{z} \in \Dipath(n) \setminus \{\bm{x},\bm{y}\}$, для которого $\bm{c'}^T \bm{z} \ge 0$.
Но это возможно, только если $\bm{z} \le \bm{x} + \bm{y}$, то есть из дуг путей $\tx$ и $\ty$ можно составить новый путь $\tilde z$. Следовательно, $\tx \symdiff \ty$ "--- не двойной путь.

Завершая доказательство, заметим, что замена ограничения $S$ отрицательным ортантом $\R^d_- = \Set{\bm{c} \in \R^d \given \bm{c} \le \bm{0}}$ лишь упрощает доказательство, избавляя от необходимости разложения сложного контура на объединение простых.
\end{proof}

В работе~\cite{BondBook:1995} приводится ошибочное утверждение, сходное с только что доказанной леммой~\ref{lem:path}, но для многогранника $s$-$t$ путей $\Path(n)$. 
Приведем его дословно:
\begin{quote} %ЦИТАТА
	\textsc{Теорема 3.4.1.}
	\textit{Точки $x$ и $y$ из $X_n$ являются смежными 
		вершинами многогранника $M(X_n)$
		в том и только том случае, когда для
		соответствующих путей $\tx, \ty \in \tilde X_n$
		симметрическая разность 
		$$
		\tx \symdiff \ty = 
		(\tx \setminus \ty) \cup (\ty \setminus \tx)
		$$
		множеств образующих их ребер составляет один простой цикл.}
\end{quote}
Нетрудно заметить, что это утверждение и лемма~\ref{lem:path} декларируют один и тот же результат, но для разных структур.
Далее в этой же работе \cite{BondBook:1995}:
\begin{quote} %ЦИТАТА
	на основе приведенного критерия смежности вершин многогранника $M(X_n)$
	задачи о кратчайшем пути определяется плотность $p(X_n)$ его графа.
	
	\textsc{Теорема 3.4.2.} 
	\textit{Справедливо равенство
		$$
		p(X_n)=\left\{
		\begin{array}{ll}
		k^2     &\mbox{при} \quad n=2k, \\
		k^2+k   &\mbox{при} \quad n=2k+1.
		\end{array}
		\right.
%		\text{>>}
		$$}
\end{quote}
Таким образом, утверждается, что кликовое число графа многогранника $s$-$t$ путей $\Path(n)$ полиномиально. С другой стороны, из утверждений раздела~\ref{sec:TSPvarious} следует $\ATSP(n) =_A \HDPst(n+1) \lea \HPst(2n) \lea \Path(2n)$. То есть кликовое число графа многогранника $\Path(n)$ сверхполиномиально. Более того, задача проверки несмежности вершин для многогранников $\ATSP$ NP-полна. Следовательно, она NP-полна и для $\Path$, что противоречит теореме 3.4.1 из~\cite{BondBook:1995}.
Лемма~\ref{lem:path} исправляет эту ошибку.
Важно то, что других ошибочных утверждений в доказательстве процитированной выше теоремы 3.4.2 не используется. Таким образом, остается только скорректировать формулировку.

\begin{theorem}[\cite{Maksimenko:2004}]
\label{thm:ShoTh2}
Кликовое число графа решений задачи о кратчайшем пути $\Dipath(n)$ с ограничением неотрицательности длин контуров равно $\lfloor n^2/4\rfloor$.
То же верно и для кликовых чисел графов полиэдров $\Path^{\uparrow}(n)$, $\Dipath^{\uparrow}(n)$ и $\ShortP(n)$.
\end{theorem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Примеры алгоритмов непрямого типа
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Примеры алгоритмов непрямого типа}
\label{sec:NondirectAlg}

В монографии~\cite{BondBook:1995} приводятся два примера полиномиально разрешимых задач, кликовые числа графов которых экспоненциальны.

Первым примером является задача линейной оптимизации на множестве вершин циклического многогранника
\[
\CP_{d,N} = \Set*{(t, t^2, \dots, t^d) \in \R^d \given t \in [N]},
\]
где $d = 4$, а $N$ полагается равным $2^n$. Так как при $d \ge 4$ все вершины этого многогранника попарно смежны, то кликовое число его графа равно $N = 2^n$. С другой стороны, эта задача может быть решена за $O(n+b)$ битовых операций~\cite{Pan:1996,Sagraloff:2016}, где $b$ "--- битовая длина целевого вектора. Более того, это можно сделать с помощью линейного разделяющего дерева высоты $O(n)$~\cite{BondBook:1995}.
В этой связи напомним, что, согласно основному результату раздела~\ref{sec:EF4Cyclic}, для $\CP_{4,N}$ можно построить расширенную формулировку размера $O(n^2)$, где $n = \log N$. То есть в этом примере сложность расширения оказывается гораздо ближе к реальной оценке сложности задачи, чем кликовое число графа. 

Второй пример основан на следующих фактах. Вместе с многогранником разбиений \begin{equation*}
\Part(A) = \Set*{\bm{x}\in\{0,1\}^m \given A \bm{x} = \bm{1}},
\end{equation*}
где $A \in \{0,1\}^{k \times m}$, рассмотрим его релаксацию
\begin{equation*}
\Part^r(A) = \Set*{\bm{x}\in\R^m_+ \given A \bm{x} = \bm{1}}.
\end{equation*}
Очевидно, $\conv(\Part(A)) \subseteq \Part^r(A)$. 
Также нетрудно показать, что множество $\Part(A)$ является подмножеством множества вершин $\ext(\Part^r(A))$.
Более того, как показал В.\,А.~Трубин~\cite{Trubin:1969}, весь граф многогранника $\conv(\Part(A))$ является подграфом графа многогранника $\Part^r(A)$.
То же верно и в отношении булева квадратичного многогранника $\BQP(n)$ и его релаксации~\cite{Bondarenko:1987}
\begin{equation}
\label{eq:BQPrelax}
\BQP^r(n) = \Set*{\bm{x} = (x_{ij})\in\R^{n(n+1)}_+ \given 
x_{ii} \ge x_{ij}, \ x_{jj} \ge x_{ij}, \ x_{ii} + x_{jj} - x_{ij} \le 1},
\end{equation}
так как эти многогранники аффинно эквивалентны $\Part(A)$ и $\Part^r(A)$, при соответствующем выборе матрицы $A \in \{0,1\}^{k \times m}$. (Для этого, например, можно воспользоваться доказательством теоремы~\ref{thm:BQPStable}, и тогда $k = n(3n-1)/2$, $m = 2n^2$.)
Таким образом, кликовое число $\omega(\BQP^r(n)) \ge \omega(\BQP(n)) = 2^n$, так как все вершины многогранника $\BQP(n)$ попарно смежны.
С другой стороны, описание~\eqref{eq:BQPrelax} многогранника $\BQP^r(n)$ компактно, следовательно, задача линейной оптимизации на нем полиномиально разрешима.
Более того, множество его вершин тоже имеет достаточно простое описание~\cite{BondBook:1995}.

В связи с этим естественным оказывается следующий вопрос.
Насколько широким является класс алгоритмов прямого (или <<прямого>>) типа?

%Отметим, что ранее в~\cite{Kolesov:2009} уже приводился пример достаточно простого
%алгоритма для решения задачи о назначениях, который не является прямым.
Оказывается, алгоритм Куна--Манкреса~\cite{Kuhn:1955,Munkres:1957} (известный также под названием венгерского алгоритма) для решения задачи о назначениях не является алгоритмом прямого (а также <<прямого>>) типа.
Кроме того, ниже будет описан достаточно универсальный способ модификации алгоритмов,
существенно не меняющий их трудоемкости, но гарантированно выводящий их из указанного класса.

\begin{theorem}[\cite{Maksimenko:2014MAIS}]
	\label{the:assignment}
	Алгоритм Куна--Манкреса для задачи о назначениях не является
	алгоритмом прямого (а также <<прямого>>) типа.
\end{theorem}

\begin{proof}
\newcommand{\cs}{c\lefteqn{'}}
	Далее предполагаем, что в рассматриваемой задаче о назначениях требуется 
	в заданном реберно"=взвешенном полном двудольном графе найти совершенное
	паросочетание минимального веса.
	Набор весов ребер является вектором входных данных задачи.
	Его удобно представлять в виде матрицы
	\[
	\bm{c} = 
	\begin{pmatrix}
	c_{11} & c_{12} & \cdots & c_{1n} \\
	c_{21} & c_{22} & \cdots & c_{2n} \\
	\vdots & \vdots & \ddots & \vdots \\
	c_{n1} & c_{n2} & \cdots & c_{nn} 
	\end{pmatrix},
	\]
	где $c_{ij}$ "--- вес ребра, соединяющего $i$-ю вершину <<нижней>> доли графа
	и $j$-ю вершину <<верхней>> доли.
	Множеством допустимых решений задачи является множество $\Birk(n)$, состоящее из булевых $n\times n$"~матриц, каждая строка и каждый столбец которых
	содержат ровно по одной единице.
%	Выпуклая оболочка всех таких матриц называется \emph{многогранником Биркгофа}.
	
	Для доказательства нам не потребуется описание всего алгоритма Куна--Ман\-кре\-са.
	Достаточно рассмотреть этап предобработки (редуцирования строк и столбцов матрицы весов).
	На этом этапе перебираются сначала вершины одной доли графа (например, <<нижней>>),
	затем другой (<<верхней>>).
	Для каждой вершины среди инцидентных ей ребер выбирается ребро с наименьшим весом.
	% (т.е. в каждой строке матрицы $c$ выбирается наименьший элемент).
	Его вес вычитается из весов всех инцидентных этой вершине ребер.
	Ребро с наименьшим весом при этом приобретает нулевой вес,
	все остальные "--- неотрицательный.
	Заметим, что после прохождения этого этапа возможна ситуация, 
	когда ребра с нулевым весом образуют паросочетание.
	Тогда, разумеется, именно оно окажется минимальным, и задача решена.
	
	Особо следует обратить внимание на то,
	что на этом этапе обычно не оговаривается способ выбора ребра с минимальным весом.
	Без явного описания этого способа рассуждения о принадлежности 
	к классу алгоритмов прямого типа становятся беспредметными.
	Обычно предполагается следующий естественный способ.
	(К тому же являющийся оптимальным по трудоемкости.)
	На первом шаге сравниваются веса двух произвольно выбранных ребер.
	Не уменьшая общности, можно считать, что это первое и второе ребро (в данной выборке).
	Далее, наименьшее из них сравнивается с весом третьего ребра и~т.\,д.
	%В свою очередь, наименьшее из последних двух сравнивается с четвертым по списку, и т.д.
	В результате последнего ($(n-1)$-го, если элементов $n$) сравнения выявляется ребро с наименьшим весом.
	
	\textbf{1. Алгоритм Куна--Манкреса не является алгоритмом прямого типа.}
	
	Согласно определению \ref{def:direct-type}, достаточно указать
	внутренний узел $f$ (точнее, некоторую операцию сравнения) 
	в дереве алгоритма и клику $Y$, состоящую из четырех допустимых решений,
	так, чтобы при любом результате сравнения два из этих четырех решений
	оказывались бы отброшенными:
	\[
	|R_f^+ \cap Y| = |R_f^- \cap Y| = 2.
	\]
	Ниже будет приведен пример для $n = 4$ вершин в каждой доле, 
	который легко масштабируется на произвольные значения $n > 4$.
	
	Рассмотрим полный двудольный граф с четырьмя вершинами в каждой доле.
	Набор весов ребер представляем в виде матрицы
	\[
	\begin{pmatrix}
	c_{11} & c_{12} & c_{13} & c_{14} \\
	c_{21} & c_{22} & c_{23} & c_{24} \\
	c_{31} & c_{32} & c_{33} & c_{34} \\
	c_{41} & c_{42} & c_{43} & c_{44} 
	\end{pmatrix}
	\]
	Предположим, как было сказано ранее, что для каждой строки, начиная с первой,
	выполняется следующая процедура.
	Вес $c_{i1}$ сравнивается с весом $c_{i2}$.
	Затем, наименьший из них сравнивается с $c_{i3}$.
	И, наконец, наименьший из последних двух сравнивается с $c_{i4}$.
	
	Обратим внимание на то, 
	что случаи равенства сравниваемых весов для теории алгоритмов прямого типа не информативны. 
	В противном случае ни в одном узле соответствующего линейного разделяющего 
	дерева не отбрасывалось бы ни одно решение. 
	(Это рассуждение носит общий характер и распространяется не только на данный алгоритм.) 
	
	Предположим теперь, что мы прошли по ветке линейного разделяющего дерева со следующими дугами
	(дуга представляет собой результат сравнения пары весов):
	1) $c_{11} < c_{12}$; \ 
	2) $c_{11} < c_{13}$; \ 
	3) $c_{11} < c_{14}$; \ 
	4) $c_{21} > c_{22}$; \ 
	5) $c_{22} < c_{23}$; \ 
	6) $c_{22} < c_{24}$.
	
	В настоящий момент мы находимся в узле $c_{31} \compare c_{32}$,
	а матрица приобрела следующий вид:
	\[
	\begin{pmatrix}
	0  & \cs_{12} & \cs_{13} & \cs_{14} \\
	\cs_{21} &     0  & \cs_{23} & \cs_{24} \\
	c_{31} & c_{32} & c_{33} & c_{34} \\
	c_{41} & c_{42} & c_{43} & c_{44} 
	\end{pmatrix},
	\]
	где $\cs_{1i} = c_{1i} - c_{11}$, $\cs_{2i} = c_{2i} - c_{22}$, $i = 1,2,3,4$.
	Заметим, что все <<ненулевые>> веса в этой матрице могут принимать любые
	положительные значения, никак не зависящие друг от друга.
	(Не уменьшая общности, можно считать, что все исходные веса положительны.) 
	
	Не трудно проверить, что из всех 24 паросочетаний данного графа
	отброшенными по итогам шести сравнений окажутся лишь следующие два
	(для удобства перечислим обозначения весов соответствующих ребер):
	$\{\cs_{12}, \cs_{21}, c_{33}, c_{44}\}$
	и~$\{\cs_{12}, \cs_{21}, c_{34}, c_{43}\}$.
	То есть множество $X_f$ узла $c_{31} \compare c_{32}$ состоит из 22 паросочетаний.
	
	Рассмотрим теперь результаты сравнения $c_{31} \compare c_{32}$.
	
	1) Если верно $c_{31} < c_{32}$, то отброшены будут 
	паросочетания $\{\cs_{21}, c_{32}, \cs_{13}, c_{44}\}$ 
	и $\{\cs_{21}, c_{32}, \cs_{14}, c_{43}\}$.
	
	2) Если верно $c_{31} > c_{32}$, то отброшены 
	$\{\cs_{12}, c_{31}, \cs_{23}, c_{44}\}$ 
	и $\{\cs_{12}, c_{31}, \cs_{24}, c_{43}\}$.
	
	Причем все четыре указанных паросочетания попарно смежны.
	Это легко проверяется с помощью критерия смежности, описанного в лемме~\ref{lem:BirkAdj}.
%	вершин многогранника Биркгофа (см., например, \cite{Emelichev:1981}).
	
%	\begin{lemma}[критерий смежности]
%		Два паросочетания смежны тогда и только тогда, 
%		когда объединение их ребер содержит ровно один цикл.
%	\end{lemma}
	
	Следовательно, при любом исходе сравнения $c_{31} \compare c_{32}$
	от данной клики из четырех решений отбрасывается ровно два.
	
	\textbf{2. Алгоритм Куна--Манкреса не является алгоритмом <<прямого>> типа.}
	
	Как было сказано ранее, уже после прохождения этапа <<предобработки>> возможна ситуация, 
	когда ребра с нулевым весом образуют паросочетание.
	В такой ситуации мы попадаем в лист линейного разделяющего дерева.
	При этом цепь, соединяющая корень дерева и этот лист,
	состоит только из узлов вида $c_{ij} \compare c_{il}$.
	
	Заметим, что для любого паросочетания можно подобрать веса ребер так,
	что наперед заданное неравенство $c_{ij} < c_{il}$ будет выполнено, 
	а суммарный вес ребер этого паросочетания
	окажется меньше веса любого другого паросочетания.
	Ровно то же самое справедливо и в отношении неравенства $c_{ij} > c_{il}$.
	Другими словами, каждый конус $K(\bm{x})$ имеет общие внутренние точки с каждым из полупространств $c_{ij} < c_{il}$ и $c_{ij} > c_{il}$.
	Следовательно, условие (*) из определения~\ref{def:direct-type2} нарушается
	для <<коротких>> цепей, заканчивающихся на этапе предобработки.
\end{proof}

Учитывая, что основой алгоритма Эдмондса~\cite{Edmonds:1965} для задачи о паросочетаниях в произвольном реберно"=взвешенном графе является алгоритм Куна--Манкреса, получаем.

\begin{corollary}
\label{cor:Edmonds}
	Алгоритм Эдмондса для задачи о паросочетаниях не является
	алгоритмом прямого (а также <<прямого>>) типа.
\end{corollary}

\begin{remark}
В \cite[с. 77]{BondBook:1995} приводится <<доказательство>> того,
что алгоритм Эдмондса является алгоритмом прямого типа (позднее этот факт дублируется в \cite[с. 87]{BondBook:2008}).
Слово доказательство здесь намеренно взято в кавычки, так как анализ принадлежности алгоритма Эдмондса классу алгоритмов прямого типа в~\cite{BondBook:1995} занимает полстраницы, где по существу излагается лишь идея доказательства. Там же на основе этого <<факта>> выводится полиномиальная верхняя оценка для кликовых чисел графов многогранника совершенных паросочетаний $\Match(n)$ и многогранника задачи о назначениях $\Birk(n)$.
Согласно следствию~\ref{cor:Edmonds}, эта идея не может быть реализована без существенной корректировки определения алгоритма прямого типа, либо модификации самого алгоритма Эдмондса. Как следствие, вопрос о существовании полиномиальных верхних оценок кликовых чисел графов многогранников $\Match(n)$ и $\Birk(n)$ остается открытым.
%, оставляющая читателю широкие возможности для самостоятельных исследований.
\end{remark}

При внимательном рассмотрении полученный результат говорит о том,
что теория алгоритмов прямого типа в форме определений~\ref{def:direct-type}
и~\ref{def:direct-type2} чувствительна к этапу предобработки,
на котором отсеиваются простые случаи.
Развивая эту идею, приведем еще один пример непрямого алгоритма.

Рассмотрим задачу о кратчайшем пути.

\textsc{Задан} полный реберно"=взвешенный граф на $n$ вершинах,
в котором выделены две вершины $s$ и $t$.

\textsc{Требуется} найти в этом графе простой путь минимальной длины
(точнее, с минимальным суммарным весом ребер), соединяющий вершины $s$ и $t$.

В предыдущем разделе уже упоминался тот факт, что кликовое число графа многогранника
задачи о кратчайшем пути сверхполиномиально.
С другой стороны, при ограничении неотрицательности длин ребер задача становится 
полиномиально разрешимой (ее трудоемкость сопоставима с числом ребер в исходном графе).
Воспользуемся этим, чтобы построить пример непрямого алгоритма.

\begin{example}[\cite{Maksimenko:2014MAIS}]
	Рассмотрим какой нибудь алгоритм (прямого типа) 
	для решения задачи о кратчайшем пути в общем виде.
	Добавим к нему этап предобработки, обслуживающий те частные случаи,
	когда выполняется условие неотрицательности длин ребер.
	(Заметим, что эта идея довольно часто реализуется на практике, 
	так как помогает существенно ускорить работу алгоритма для простых случаев.)
	Соответственно, общая глубина дерева алгоритма увеличится на число операций,
	необходимых для проверки условия неотрицательности.
	Особо обратим внимание на то, что в ходе этой проверки
	\emph{ни одно решение не отбрасывается}.
	(Хотя бы потому, что длины ребер сравниваются с нулем, а не друг с другом.)
	В том месте (узле), где вся эта проверка успешно заканчивается, 
	у дерева появляется еще одна ветвь, 
	реализующая решение для случая неотрицательных длин.
	Причем множество пометок листьев этой ветви совпадает с множеством всех решений.
	(Так как ни одно решение в ходе проверки условия неотрицательности не было отброшено.)
	Важно то, что эта ветвь полностью сохраняет множество решений исходной общей задачи,
	но при этом имеет полиномиальную глубину, так как соответствующий
	частный случай полиномиально разрешим.
	С другой стороны, как было замечено ранее, 
	кликовое число для этой задачи сверхполиномиально.
	Сопоставляя эти факты с теоремой~\ref{the:direct-type},
	приходим к выводу, что рассматриваемая ветвь, а вместе с ней и все дерево, не является ни прямым, ни <<прямым>>.
\end{example}

Все это говорит о том, что ограничения, накладываемые определениями~\ref{def:direct-type} и~\ref{def:direct-type2}, являются слишком жесткими и не выполняются, в том числе, для некоторых классических алгоритмов.
Кроме того, проверка этих ограничений (в том случае, если они действительно выполняются), как правило, сложнее непосредственной оценки трудоемкости алгоритма,
что существенно снижает ценность теоремы~\ref{the:direct-type}.

%В заключение заметим, что несмотря на указанные недостатки теория алгоритмов прямого типа послужила отправной точкой для ряда новых исследований, приоткрывающих завесу над глубинными причинами труднорешаемости задач комбинаторной оптимизации.
%В частности, автор настоящей работы благодарен В.А. Бондаренко за знакомство с этой интересной теорией.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% End of section
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
