%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Алгоритмы прямого типа
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{\texorpdfstring{Кликовое число полиэдрального графа\\ и алгоритмы прямого типа}{Кликовое число полиэдрального графа и алгоритмы прямого типа}}
\label{sec:Direct}

\hfill
\begin{minipage}{0.55\textwidth}
Плотность графа многогранника задачи служит нижней оценкой вычислительной сложности в широком классе алгоритмов, основанных на линейных сравнениях.
\begin{flushright}
В.\,А.~Бондаренко
\end{flushright}
\end{minipage}

\section{Теория алгоритмов прямого типа}

В монографии \cite{BondBook:1995} кликовое число графа многогранника 
рассматривается как нижняя оценка сложности соответствующей задачи
в <<некотором широком>> классе так называемых алгоритмов прямого типа. 
Алгоритмы прямого типа относятся к классу линейных разделяющих алгоритмов,
которые удобно представлять в виде линейных разделяющих деревьев.

В этой главе, следуя \cite{BondBook:1995}, задачей будет называться множество допустимых решений $X = X(I) \in \R^m$, из которого требуется выбрать решение $\bm{x}$, оптимальное относительно подаваемого на вход задачи целевого вектора $\bm{c} \in \R^m$.
Также, как это было сделано в разделе~\ref{sec:Cones}, для каждого $\bm{x} \in X$ определим конус исходных данных
\begin{equation}
\label{eq:cone}
K(\bm{x}) = \Set*{\bm{c}\in \R^m \given  \bm{c}^T \bm{x} \ge \bm{c}^T \bm{y}, \ \forall \bm{y} \in X}.
\end{equation}
В случае, если множество исходных данных задачи ограничено полиэдром $Q \subseteq \R^m$, используем обозначение $K(\bm{x}, Q) = K(\bm{x}) \cap Q$.

\begin{definition}[{\cite{BondBook:1995}}] %{\cite[с. 33]{BondBook:1995}}
	Линейным  разделяющим деревом задачи $X \subset \R^m$ называется ориентированное дерево, обладающее следующими свойствами:
	\begin{itemize}
		\item[а)] 
		в каждый узел, за исключением одного, называемого  корнем,
		входит ровно одна дуга; дуг, входящих в корень, нет;
		\item[б)] 
		для каждого узла либо имеется две выходящих из него  дуги,
		либо таких дуг  нет  вообще;   в  первом  случае  узел  называется
		внутренним, во втором "--- внешним, или листом;
		\item[в)] 
		каждому внутреннему узлу соответствует некоторый вектор $\bm{f} \in \R^m$;
		\item[г)] 
		каждому листу соответствует некоторый элемент множества $X$;
		\item[д)] 
		каждой дуге $d$ соответствует число  $\sgn d$, равное $1$ либо $-1$;
		две дуги, выходящие из одного узла, имеют различные значения;
		\item[е)] 
		для каждой цепи $W = \bm{f_1} d_1 \bm{f_2} d_2 \ldots \bm{f_l} d_l \bm{x}$, соединяющей корень и лист (в обозначении  цепи  перечислены  соответствующие  ее  узлам векторы; дуга $d_i$ выходит из узла $\bm{f_i}$, $i\in[l]$), и для любого $\bm{c}\in \R^m$ из неравенств $\bm{c}^T \bm{f_i} \sgn d_i\ge 0$, $i\in[l]$, следует включение $\bm{c}\in K(\bm{x})$.
	\end{itemize}
\end{definition}

\emph{Сложностью $C_{LSA}(X)$ задачи $X$ в классе линейных разделяющих алгоритмов}
называется высота (глубина) минимального линейного разделяющего дерева этой задачи.
Очевидно, $C_{LSA}(X) \ge \log_2 |X|$ (разумеется, при условии, 
что $X$ не содержит решений, не являющихся оптимальными ни при каком входе $c$).
В~1982~г. М.\,Ю.~Мошков показал~\cite{Moshkov:1982}, что $C_{LSA}(X) = O (m^3 \log_2 |X|)$ для любой задачи $X\in\R^m$. То есть NP-трудные задачи приравниваются к полиномиально разрешимым в классе линейных разделяющих алгоритмов.
Такое положение дел заставляет предположить, 
что существующие алгоритмы удовлетворяют некоторым дополнительным ограничениям,
существенно снижающим их эффективность.
Одно из таких ограничений было предложено в~1980"~х~гг. В.\,А.~Бондаренко.

Введем, следуя \cite{BondBook:1995}, несколько вспомогательных обозначений.
Пусть $T$ "--- линейное  разделяющее  дерево  задачи $X$  и
пусть $\bm{f}$ "---  его  внутренний  узел.
Обозначим через $X_f$  множество пометок всех листьев дерева $T$,
которым  предшествует  узел $\bm{f}$, а через $X_f^+$ и $X_f^-$  обозначим
подмножества $X_f$, соответствующие  двум выходящим из $\bm{f}$ дугам.
Обозначим через $R_f^- = X_f^+ \setminus X_f^-$ множество пометок,
отбрасываемых при переходе по <<отрицательной>> дуге.
По аналогии определим множество пометок $R_f^+ = X_f^- \setminus X_f^+$,
отбрасываемых при переходе по <<положительной>> дуге.

В \cite{BondBook:1995} предложены два формально разных варианта определения
алгоритма прямого типа, в основе которых лежит одна и та же идея,
для описания которой понадобится понятие клики решений.
Множество решений $Y \subseteq X$ называется \emph{кликой},
если любые два решения $\bm{x}, \bm{y} \in Y$ смежны, 
то есть при некотором входе $\bm{c}$ удовлетворяют неравенству
\begin{equation*}
%\label{eq:adjacent}
\bm{c}^T \bm{x} = \bm{c}^T \bm{y} > \bm{c}^T \bm{z}, \qquad \forall \bm{z}\in X \setminus \{\bm{x}, \bm{y}\}.
\end{equation*}
(Это определение смежных решений подходит как для вершин многогранника $\conv(X)$, так и для конусов разбиения $\K(X,Q)$.)
Мощность максимальной клики в $X$ обозначаем $\omega(X)$.

\begin{definition}[{\cite{BondBook:1995}}] %[{\cite[с. 39]{BondBook:1995}}]
	\label{def:direct-type}
	Линейное разделяющее  дерево $T$ задачи $X$
	называется деревом прямого типа, если для любого внутреннего узла $\bm{f}$ и
	для любой клики $Y \subseteq X$ выполняется неравенство
	\begin{equation}
	\min \{ |R_f^+ \cap Y|, |R_f^- \cap Y| \} \le 1.
	\label{eq:direct-type}
	\end{equation}
\end{definition}


\begin{definition}[{\cite{BondBook:1995}}] %[{\cite[с. 40]{BondBook:1995}}]
	\label{def:direct-type2}
	Деревом <<прямого  типа>> задачи $X$, $X\in R^m$,
	называется линейное разделяющее  дерево  этой  задачи,  для  которого
	каждая цепь $w = \bm{f_1} d_1 \bm{f_2} d_2 \ldots \bm{f_l} d_l \bm{x}$,  соединяющая  корень  и  лист,
	удовлетворяет условиям:
	\begin{itemize}
		\item[(*)] 
		для любого $\bm{y}\in X$ смежного  с $\bm{x}$,  найдется  такой  номер $i\in [l]$, что условия $\bm{c}^T \bm{f_i} \sgn d_i > 0$ и $\bm{c}\in K(\bm{y})$ несовместны;
		\item[(**)] 
		для любого $i\in[l]$ из несовместности условий
		\[
		\bm{c}^T \bm{f_i} \sgn d_i > 0 \qquad \mbox{и} \qquad \bm{c}\in K(\bm{y})
		\]
		для $\bm{y}$, смежного с $\bm{x}$, и из телесности конуса
		\[
		K(\bm{x}) \cap \Set*{ \bm{c}\in R^m \given \bm{c}^T \bm{f_i} \sgn d_i \le 0}
		\]
		следует, что ветвь, начинающаяся в узле $\bm{f_i}$ с  дугой  $-d_i$,  имеет хотя бы один лист, помеченный $\bm{x}$.
	\end{itemize}
\end{definition}

Оба этих определения объединяет следующий факт.

\begin{theorem}[{\cite{BondBook:1995}}] %[{\cite[раздел 2.4]{BondBook:1995}}]
\label{the:direct-type}
Высота дерева прямого типа (<<прямого типа>>) задачи $X$ не меньше $\omega(X)-1$.
\end{theorem}

Таким образом, мощность максимальной клики является нижней оценкой трудоемкости
для такого типа алгоритмов.
Как показали многочисленные исследования, 
для классических полиномиально разрешимых задач 
(сортировка, минимальное остовное дерево, кратчайший путь в графе, минимальный разрез)
эта характеристика не превосходит размерности многогранника \cite{Bondarenko:2008, Nikolaev:2013}.
С другой стороны, оказалось, что $\BQP(n)$ является гранью
многогранников таких труднорешаемых задач, как коммивояжер,
рюкзак, 3-выполнимость, 3-сочетание, покрытие и упаковка множества,
кубический подграф и многих других \cite{Maksimenko:2016bool}.
Учитывая, что кликовое число графа многогранника $\BQP(n)$ равно $2^n$,
кликовые числа графов многогранников указанных задач также
суперполиномиальны по размерности многогранников.
Кроме того, в \cite{BondBook:1995} установлено, 
что некоторые алгоритмы сортировки, жадные алгоритмы для минимального остовного дерева,
алгоритм Дейкстры для кратчайшего пути, алгоритм Хелда--Карпа 
и реализация алгоритма ветвей и границ для задачи коммивояжера
являются прямыми или <<прямыми>>.
(Хотя, в контексте приводимых ниже замечаний, 
некоторые из этих результатов могут быть подвергнуты сомнению.)

Ограниченность такого подхода к оценке сложности задач иллюстрируется следующими фактами.

\begin{example}
	Как уже было сказано выше, для многогранников полиномиально разрешимых задач
	кликовое число графа как правило не превосходит размерности многогранника.
	Т.е. такая тривиальная оценка, как размерность многогранника 
	мажорирует эту характеристику.
	Кроме того, явно сравнимые по сложности задачи могут иметь <<несравнимые>> кликовые числа.
	Например, задача выбора наибольшего элемента в массиве из $n$ элементов 
	очевидно проще задачи сортировки.
	Многогранник первой задачи представляет собой симплекс \cite{BondBook:1995}.
	Его граф полный. Следовательно, кликовое число равно $n$.
	Многогранник второй задачи называется \emph{перестановочным},
	а кликовое число его графа равно 2 \cite{Gaiha:1977}.
	Т.е. в данном случае кликовое число никак не связано с реальной сложностью задачи.
\end{example}

\begin{example}
	В \cite{BondBook:1995} на основе релаксации многогранника $\BQP(n)$
	строится пример полиномиально разрешимой задачи с экспоненциальным
	кликовым числом графа многогранника.
\end{example}

\begin{example}
	Для любых натуральных $k$ и $m$ известны примеры $k$-смежностных многогранников 
	на $m$ вершинах, допускающих полиномиальное относительно $\log m$ описание \cite{BogomolovFMP:2015}.
	%сложность расширенной формулировки равна $O(\log^k m)$
\end{example}


Приведенные примеры говорят о том, 
что для полиномиально разрешимых задач размерность многогранника
во многих случаях оказывается гораздо более точной характеристикой сложности, 
чем кликовое число графа.
В случае же многогранников NP-трудных задач высокое значение кликового числа
объясняется тем, что многогранник $\BQP(n)$ оказывается
гранью этих многогранников в силу естественных причин,
обусловленных (аффинной) сводимостью \cite{Maksimenko:2016bool}.

В связи с этим естественным оказывается следующий вопрос.
Насколько широким является класс алгоритмов прямого (<<прямого>>) типа?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Примеры алгоритмов непрямого типа
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Примеры алгоритмов непрямого типа}

Отметим, что ранее в \cite{Kolesov:2009} уже приводился пример достаточно простого
алгоритма для решения задачи о назначениях, который не является прямым.
В настоящей работе будет показано, что алгоритм Куна--Манкреса 
(известный также под названием венгерского алгоритма) не является
алгоритмом прямого (а также <<прямого>>) типа.
Кроме того, будет описан достаточно универсальный способ модификации алгоритмов,
существенно не меняющий их трудоемкости, но гарантированно выводящий их из указанных классов.

\begin{theorem}
	\label{the:assignment}
	Алгоритм Куна--Манкреса для задачи о назначениях не является
	алгоритмом прямого (а также <<прямого>>) типа.
\end{theorem}

\begin{proof}
	Далее предполагаем, что в рассматриваемой задаче о назначениях требуется 
	в заданном реберно взвешенном полном двудольном графе найти совершенное
	паросочетание минимального веса.
	Набор весов ребер является вектором входных данных задачи.
	Его удобно представлять в виде матрицы
	\[
	\bm{c} = 
	\begin{pmatrix}
	c_{11} & c_{12} & \cdots & c_{1n} \\
	c_{21} & c_{22} & \cdots & c_{2n} \\
	\vdots & \vdots & \ddots & \vdots \\
	c_{n1} & c_{n2} & \cdots & c_{nn} 
	\end{pmatrix},
	\]
	где $c_{ij}$ "--- вес ребра, соединяющего $i$-ю вершину <<нижней>> доли графа
	и $j$-ю вершину <<верхней>> доли.
	При таком подходе допустимые решения задачи представляются в виде булевых 
	$n\times n$-матриц, каждая строка и каждый столбец которых
	содержат ровно по одной единице.
	Выпуклая оболочка всех таких матриц называется \emph{многогранником Биркгофа}.
	
	Для доказательства нам не потребуется описание всего алгоритма Куна--Ман\-кре\-са.
	Достаточно рассмотреть этап предобработки (редуцирования строк и столбцов матрицы весов).
	На этом этапе перебираются сначала вершины одной доли графа (например, <<нижней>>),
	затем другой (<<верхней>>).
	Для каждой вершины среди инцидентных ей ребер выбирается ребро с наименьшим весом.
	% (т.е. в каждой строке матрицы $c$ выбирается наименьший элемент).
	Его вес вычитается из весов всех инцидентных этой вершине ребер.
	Ребро с наименьшим весом при этом приобретает нулевой вес,
	все остальные "--- неотрицательный.
	Заметим, что после прохождения этого этапа возможна ситуация, 
	когда ребра с нулевым весом образуют паросочетание.
	Тогда, разумеется, именно оно окажется минимальным, и задача решена.
	
	Особо следует обратить внимание на то,
	что на этом этапе обычно не оговаривается способ выбора ребра с минимальным весом.
	Без явного описания этого способа рассуждения о принадлежности 
	к классу алгоритмов прямого типа становятся беспредметными.
	Обычно предполагается следующий естественный способ.
	(К тому же являющийся оптимальным по трудоемкости.)
	На первом шаге сравниваются веса двух произвольно выбранных ребер.
	Не уменьшая общности, можно считать, что это первое и второе ребро (в данной выборке).
	Далее, наименьшее из них сравнивается с весом третьего ребра и т.д.
	%В свою очередь, наименьшее из последних двух сравнивается с четвертым по списку, и т.д.
	В результате последнего ($(n-1)$-го, если элементов $n$) сравнения выявляется ребро с наименьшим весом.
	
	\textbf{1. Алгоритм Куна--Манкреса не является алгоритмом прямого типа.}
	
	Согласно определению \ref{def:direct-type} достаточно указать
	внутренний узел $f$ (точнее, некоторую операцию сравнения) 
	в дереве алгоритма и клику из четырех допустимых решений $Y$
	так, чтобы при любом результате сравнения два из этих четырех решений
	оказывались бы отброшенными:
	\[
	|R_f^+ \cap Y| = |R_f^- \cap Y| = 2.
	\]
	Ниже будет приведен пример для $n = 4$ вершин в каждой доле, 
	который легко масштабируется на произвольные значения $n > 4$.
	
	Рассмотрим полный двудольный граф с четырьмя вершинами в каждой доле.
	Набор весов ребер представляем в виде матрицы
	\[
	\begin{pmatrix}
	c_{11} & c_{12} & c_{13} & c_{14} \\
	c_{21} & c_{22} & c_{23} & c_{24} \\
	c_{31} & c_{32} & c_{33} & c_{34} \\
	c_{41} & c_{42} & c_{43} & c_{44} 
	\end{pmatrix}
	\]
	Предположим, как было сказано ранее, что для каждой строки, начиная с первой,
	выполняется следующая процедура.
	Вес $c_{i1}$ сравнивается с весом $c_{i2}$.
	Затем, наименьший из них сравнивается с $c_{i3}$.
	И, наконец, наименьший из последних двух сравнивается с $c_{i4}$.
	
	Обратим внимание на то, 
	что случаи равенства сравниваемых весов для теории алгоритмов прямого типа не информативны. 
	В противном случае ни в одном узле соответствующего линейного разделяющего 
	дерева не отбрасывалось бы ни одно решение. 
	(Это рассуждение носит общий характер и распространяется не только на данный алгоритм.) 
	
	Предположим теперь, что мы прошли по ветке линейного разделяющего дерева со следующими дугами
	(дуга представляет собой результат сравнения пары весов):
	1) $c_{11} < c_{12}$; \ 
	2) $c_{11} < c_{13}$; \ 
	3) $c_{11} < c_{14}$; \ 
	4) $c_{21} > c_{22}$; \ 
	5) $c_{22} < c_{23}$; \ 
	6) $c_{22} < c_{24}$.
	
	В настоящий момент мы находимся в узле $c_{31} \compare c_{32}$,
	а матрица приобрела следующий вид:
	\[
	\begin{pmatrix}
	0  & c'_{12} & c'_{13} & c'_{14} \\
	c'_{21} &     0  & c'_{23} & c'_{24} \\
	c_{31} & c_{32} & c_{33} & c_{34} \\
	c_{41} & c_{42} & c_{43} & c_{44} 
	\end{pmatrix},
	\]
	где $c'_{1i} = c_{1i} - c_{11}$, $c'_{2i} = c_{2i} - c_{22}$, $i = 1,2,3,4$.
	Заметим, что все <<не нулевые>> веса в этой матрице могут принимать любые
	положительные значения, никак не зависящие друг от друга.
	(Не уменьшая общности, можно считать, что все исходные веса положительны.) 
	
	Не трудно проверить, что среди всех 24 паросочетаний данного графа
	отброшенными по итогам шести сравнений окажутся лишь следующие два
	(для удобства перечислим обозначения весов соответствующих ребер):
	$\{c'_{12}, c'_{21}, c_{33}, c_{44}\}$
	и $\{c'_{12}, c'_{21}, c_{34}, c_{43}\}$.
	Т.е. множество $X_f$ узла $c_{31} \compare c_{32}$ состоит из 22 паросочетаний.
	
	Рассмотрим теперь результаты сравнения $c_{31} \compare c_{32}$.
	
	1) Если верно $c_{31} < c_{32}$, то отброшены будут 
	паросочетания $\{c'_{21}, c_{32}, c'_{13}, c_{44}\}$ 
	и $\{c'_{21}, c_{32}, c'_{14}, c_{43}\}$.
	
	2) Если верно $c_{31} > c_{32}$, то отброшены 
	$\{c'_{12}, c_{31}, c'_{23}, c_{44}\}$ 
	и $\{c'_{12}, c_{31}, c'_{24}, c_{43}\}$.
	
	Причем все четыре указанных паросочетания попарно смежны.
	Это легко проверяется, например, с помощью известного критерия смежности
	вершин многогранника Биркгофа (см., например, \cite{Emelichev:1981}).
	
	\begin{lemma}[критерий смежности]
		Два паросочетания смежны тогда и только тогда, 
		когда объединение их ребер содержит ровно один цикл.
	\end{lemma}
	
	Следовательно, при любом исходе сравнения $c_{31} \compare c_{32}$
	от данной клики из четырех решений отбрасывается ровно два.
	
	\textbf{2. Алгоритм Куна--Манкреса не является алгоритмом <<прямого>> типа.}
	
	Как было сказано ранее, уже после прохождения этапа <<предобработки>> возможна ситуация, 
	когда ребра с нулевым весом образуют паросочетание.
	В такой ситуации мы попадаем в лист линейного разделяющего дерева.
	При этом цепь, соединяющая корень дерева и этот лист,
	состоит только из узлов вида $c_{ij} \compare c_{il}$.
	
	Заметим, что для любого паросочетания можно подобрать веса ребер так,
	что наперед заданное неравенство $c_{ij} < c_{il}$ будет выполнено, 
	а суммарный вес ребер этого паросочетания
	окажется меньше веса любого другого паросочетания.
	Ровно то же самое справедливо и в отношении неравенства $c_{ij} > c_{il}$.
	Другими словами, каждый конус $K(\bm{x})$ имеет общие внутренние точки с каждым из полупространств $c_{ij} < c_{il}$ и $c_{ij} > c_{il}$.
	Следовательно, условие (*) из определения~\ref{def:direct-type2} нарушается
	для <<коротких>> цепей, заканчивающихся на этапе предобработки.
\end{proof}

В \cite[с. 77]{BondBook:1995} приводится <<доказательство>> того,
что алгоритм Эдмондса для задачи о паросочетаниях в произвольном реберно взвешенном графе
является алгоритмом прямого типа.
(Позднее этот факт дублируется в \cite{Bondarenko:2008}.)
Слово доказательство здесь намеренно взято в кавычки, 
так как сам алгоритм Эдмондса представляет собой достаточно непростую модификацию
алгоритма Куна--Манкреса, а анализ его принадлежности к алгоритмам прямого типа
в \cite{BondBook:1995} занимает полстраницы, 
где по существу излагается лишь идея доказательства,
оставляющая читателю широкие возможности для самостоятельных исследований.
Учитывая, что основой алгоритма Эдмондса является алгоритм Куна--Манкреса,
доказательство теоремы~\ref{the:assignment} переносится и на этот случай.

\begin{corollary}
	Алгоритм Эдмондса для задачи о паросочетаниях в произвольном графе не является
	алгоритмом прямого (а также <<прямого>>) типа.
\end{corollary}

При внимательном рассмотрении полученный результат говорит о том,
что теория алгоритмов прямого типа в форме определений~\ref{def:direct-type}
и~\ref{def:direct-type2} чувствительна к этапу предобработки,
на котором отсеиваются простые случаи.
Развивая эту идею, приведем еще один пример непрямого алгоритма.

Рассмотрим задачу о кратчайшем пути.

\textsc{Задан} полный реберно взвешенный граф на $n$ вершинах,
в котором выделены две вершины $s$ и $t$.

\textsc{Требуется} найти в этом графе простой путь минимальной длины
(точнее, с минимальным суммарным весом ребер), соединяющий вершины $s$ и $t$.

Хорошо известно \cite{Garey:1982}, что при отсутствии ограничений на веса ребер
эта задача является NP-трудной. 
Более того, ее многогранник содержит в качестве грани многогранник задачи коммивояжера, а следовательно, кликовое число графа многогранника
задачи о кратчайшем пути сверхполиномиально \cite{Maksimenko:2004}.
С другой стороны, при ограничении неотрицательности длин ребер задача становится 
полиномиально разрешимой (ее трудоемкость сопоставима с числом ребер в исходном графе).
Воспользуемся этим, чтобы построить пример непрямого алгоритма.

\begin{example}
	Рассмотрим какой нибудь алгоритм (прямого типа) 
	для решения задачи о кратчайшем пути в общем виде.
	Добавим к нему этап предобработки, обслуживающий те частные случаи,
	когда выполняется условие неотрицательности длин ребер.
	(Заметим, что эта идея довольно часто реализуется на практике, 
	так как помогает существенно ускорить работу алгоритма для простых случаев.)
	Соответственно, общая глубина дерева алгоритма увеличится на число операций,
	необходимых для проверки условия неотрицательности.
	Особо обратим внимание на то, что в ходе этой проверки
	ни одно решение не отбрасывается.
	(Хотя бы потому, что длины ребер сравниваются с нулем, а не друг с другом.)
	В том месте (узле), где вся эта проверка успешно заканчивается, 
	у дерева появляется еще одна ветвь, 
	реализующая решение для случая неотрицательных длин.
	Причем множество пометок листьев этой ветви совпадает с множеством всех решений.
	(Т.к. ни одно решение в ходе проверки условия неотрицательности не было отброшено.)
	Важно то, что эта ветвь полностью сохраняет множество решений исходной общей задачи,
	но при этом имеет полиномиальную глубину, так как соответствующий
	частный случай полиномиально разрешим.
	С другой стороны, как было замечено ранее, 
	кликовое число для этой задачи суперполиномиально.
	Сопоставляя эти факты с теоремой~\ref{the:direct-type},
	приходим к выводу, что данный алгоритм не является ни прямым, ни <<прямым>>.
\end{example}

Все это говорит о том, что ограничения, накладываемые определениями~\ref{def:direct-type} и~\ref{def:direct-type2} не являются естественными.
Кроме того, проверка этих ограничений (в том случае, если они действительно выполняются) как правило сложнее непосредственной оценки трудоемкости алгоритма,
что существенно снижает ценность теоремы~\ref{the:direct-type}.

%В заключение заметим, что несмотря на указанные недостатки теория алгоритмов прямого типа послужила отправной точкой для ряда новых исследований, приоткрывающих завесу над глубинными причинами труднорешаемости задач комбинаторной оптимизации.
%В частности, автор настоящей работы благодарен В.А. Бондаренко за знакомство с этой интересной теорией.s



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Задача о кратчайшем пути
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Кликовое число для задачи о кратчайшем пути}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% End of section
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
